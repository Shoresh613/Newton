/* XACC.C - Routinen zur Behandlung des XACC-Protokolls
            nach der Spezifikation vom 28. November 1992,
            erweitert um Mag!X 2.0
	(c) 1993 Harald Sommerfeldt @ KI im Maus-Netz
	E-Mail:  Harald_Sommerfeldt@ki.maus.de */
/* Geschichte:
	22.03.93: erste Version
	03.08.93: lÑuft auch unter Speicherschutz (MiNT)
	05.09.93: Åberarbeitet und als seperater Quelltext XACC.C
	06.09.93: fÑngt als PRG den fatalen Fehler von Watchdog 1.4 ab, welches im
	          Singletasking-Fall als Antwort von ACC_ID fÑlschlicherweise
	          fleiûig ACC_ACC's verschickt, die auch noch eine falsche ID (16)
	          enthalten, so daû das AES sich die Kugel gibt, falls man versucht,
	          darauf zu antworten :-(((
	09.09.93: - neue Funktion xacc_malloc()
	          - die Variable 'xacc' wird nun beachtet
	          - Mag!X-Versionsabfrage, um Endlosschleife bei Mag!X 1.x zu verhindern
*/
/* Hinweise:
	- dieser Quelltext ist Freeware und darf daher nur umsonst und nur
	  komplett (XACC.C, XACC.H, XACCTEST.C, XACCTEST.PRJ, XACCTEST.PRG,
	  XACC2.TXT) weitergegeben werden!
	- dieser Quelltext kann ohne Hinweis auf mein Copyright in eigene Programme
	  nach belieben eingebunden werden, die Entfernung meines Copyrightes in
	  diesem Quelltext ist jedoch nicht erlaubt!
	- dieser Quelltext wurde mit Tabweite 3 entwickelt
*/
/* Dieses Routinen funktionieren auch, wenn das Programm als ACC lÑuft.
	Ist dies bei eigenen Programmen nicht der Fall, so kînnen die dafÅr
	zustÑndigen Routinen durch Lîschung dieser Zeile ausmaskiert werden,
	um redundanten Quellcode zu vermeiden. */
/* Dieses Routinen funktionieren auch, wenn das Programm als PRG lÑuft. */
/* #define XACC_RECONLY */
/* Diese Routinen kînnen nur per XACC empfangen, nicht selber senden.
	Dies ist z.B. sinnvoll, wenn man als ACC das XACC nicht aktiv benutzt,
	d.h. selbst keine Applikationen anmorsen will, man kann aber korrekt
	durch XACC angesprochen werden.
   Das XACC-Protokoll ist hierbei vollstÑndig implementiert!!! */
/* benîtigte AES-Definitionen */
#define ap_version	_GemParBlk.global[0]	/* AES-Versionsnummer (z.B. 0x140 = 1.40) */
#define ap_count		_GemParBlk.global[1]	/* Anzahl der max. laufenden Applikationen */
#define ap_id			appl_id /*_GemParBlk.global[2]*/	/* eigene ID */
/* benîtigte allgemeine Definitionen */
/*typedef enum { FALSE, TRUE } boolean;*/
/* globale Variablen */
static boolean xacc;						/* XACC-Protokoll aktiviert */
static boolean xacc_singletask;		/* alte Spezifikation vom 12.3.89 verwenden? */
static char *xacc_name;				/* Platz fÅr den eigenen XACC-Namen */
static unsigned xacc_groups;		/* eigenes XACC-Group-Wort */
static int xacc_menuid;				/* die ID des MenÅeintrages bzw. -1 */
struct xaccs xaccs[MAX_XACC];		/* Strukturen, um sich die XACC-Partner zu merken */
/* XACC-Protokoll initialisieren,
	diese Routine MUSS beim Programmstart irgendwann nach appl_init() aufgerufen werden */
	/* den XACC-Namen in einem global zugÑnglichen Block (Speicherschutz!) unterbringen */
	/* die MenÅ-ID und das Group-Wort merken */
	/* erstmal alle EintrÑge lîschen */
	/* unter einem Multi-AES-TOS gilt die neue Spezifikation... */
		/* AES 4.0 (z.B. MTOS) oder MagX 2.x ? */
			/* ...wir senden also an alle Applikationen unseren Willkommensgruû */
		else xacc = FALSE;		/* sorry, wird wohl nichts draus... */
	/* ansonsten handelt es sich um ein altes, trostloses Singletasking-AES,
	   wo wir das angestaubte XACC-Protokoll vom 12.3.89 verwenden */
/*	XACC-Protokoll deinitialisieren,
	diese Routine MUSS irgendwann beim Programmende vor appl_exit() aufgerufen werden */
	/* Im Multitasking-Fall ... */
		/* ... verabschieden wir und brav und hîflich (mittels ACC_EXIT) */
/* einen globalen (und damit fÅr XACC geeigneten) Speicherblock allozieren */
/*	die Nachricht in msgbuf verarbeiten, falls es sich um eine
	Nachricht des Types AC_CLOSE, ACC_ID, ACC_ACC oder ACC_EXIT handelt;
	es wird TRUE zurÅckgegeben, falls die Nachricht komplett verarbeitet wurde */
		/*	wenn wir dem Singletasking-Protokoll hîrig sind,
			ist dies der Moment, wo der Elefant das Wasser lÑût:
			das XACC-Protokoll wird angekurbelt */
			/* erstmal alle EintrÑge lîschen... */
			/*	...dann die Lawine in Gang setzen: ACC_ID ans Haupt-
				programm verschicken; die Bedingung ap_id != 0 sollte
				hierbei eigentlich immer erfÅllt sein, aber man weiû
				ja nie, wer einem so alles eine AC_CLOSE-Nachricht
				andrehen will (z.B. Schlemi) */
		/* wenn wir dem Single-Tasking-Protokoll hîrig sind,
			ist dies der Moment, wo der Elefant das Wasser gelassen hat:
			das XACC-Protokoll wurde angekurbelt */
			if ( ap_id == 0 ) {	/* nur wenn wir ein PRG sind... */
				/* ...verschicken wir fleiûig Gruûkarten (ACC_ACC) */
				/* dem Auslîser dieser Lawine einen Heiratsantrag schicken */
		/* im Falle des Multitasking-Protokolls tut sich hier nicht
			ganz so viel: Wir erwiedern das Moin (ACC_ID) mit Moin-Moin (ACC_ACC) */
		/* auf jeden Fall lassen wir ein ACC_ID nicht ungestraft
			durchgehen, der Absender wird in der Fahndungsliste vermerkt! */
		/* ACC_ACC ist vergleichsweise harmlos: Im Singletasking-Fall
			erhalten wir so als ACC von anderen ACCs Kenntnis (und
			vermitteln diesen die Kenntnis Åber uns), im Multitasking-Fall
			ist dies einfach das Moin-Moin auf das Moin (ACC_ID)
			ACHTUNG: Im ersten Fall steht die interessante Id bei
			         msgbuf[7], im zweiteren bei msgbuf[1]! */
			if ( ap_id != 0 ) {	/* sollte eigentlich immer der Fall sein,
			                        im Falle Watchdog 1.4 leider nicht :-((( */
		/* Der Untergang der Titanic, hier allerdings nicht ohne
			VorankÅndigung: Die Id wird mangels grÅnen Punkt nicht
			wiederverwertet, sondern wandert auf den MÅll */
		xacc_killid( msgbuf[1] );		/* wech mit den Altlasten */
/* ein Teil des Ganzen als XACC-Nachricht versenden
	dest_id : die ap_id des glÅcklichen EmpfÑngers
	message : Nachrichtentyp (ACC_IMG oder ACC_META)
	addr    : Adresse des Speicherblockes
	length  : LÑnge des Speicherblockes
	last    : Letzter Speicherblock? (FALSE/TRUE) */
/* ACC_ACK als Antwort auf ACC_TEXT, ACC_KEY, ACC_META oder ACC_IMG versenden
	dest_id : die ap_id des (un-)glÅcklichen EmpfÑngers
	ok      : TRUE oder FALSE */
/* die eigene XACC-ID versenden
	dest_id : die ap_id des glÅcklichen EmpfÑngers
	message : ACC_ID oder ACC_ACC, je nach Lust & Laune */
	/* da in xacc_init() die eigene ap_id nicht herausgefiltert wird,
	   wird hier verhindert, daû wir uns selber eine Nachricht schicken */
		msgbuf[0] = message;			/* Nachrichtentyp */
		msgbuf[1] = ap_id;			/* unsere ap_id */
		msgbuf[2] = 0;					/* LÑnge der Nachricht - 16 */
		msgbuf[3] = xacc_groups;	/* die von uns unterstÅtzten XACC-Gruppen */
		*(const char **)(msgbuf+4) = xacc_name;	/* unser XACC-Name */
		msgbuf[6] = xacc_menuid;	/* unsere MenÅkennung (falls ACC), sonst -1 */
		msgbuf[7] = NIL;				/* reserviert */
/* XACC-Eintrag vermerken (bei ACC_ID & ACC_ACC)
	id     : die ap_id des Absenders,
	msgbuf : der empfangene Nachrichtenpuffer */
	/* eventuell alten Eintrag mit der gleichen Id vorher lîschen.
	   es gibt verschiedene FÑlle, wo dies notwendig ist:
	   - ein Eintrag ist veraltet, da das Programm abgestÅrzt ist
	     und daher kein ACC_EXIT versandt hat
	   - beim Singletasking-Protokoll kann ein ACC mehrere ACC_ACC
	     vom gleichen ACC erhalten
	   - beim Multitasking-Protokolls erhÑlt ein ACC _IMMER_ von einem
	     anderen ACC beim Neustart des Rechners sowohl ein ACC_ID als
	     auch ein ACC_ACC
	*/
	/* nun gehts aber los! */
	for ( i = 0; i < MAX_XACC; i++ ) {	/* XACC-Liste abklappern */
		if ( xaccs[i].id < 0 ) {				/* freier Eintrag gefunden */
			xaccs[i].id = id;					/* Eintrag vermerken */
/* XACC-Eintrag lîschen (z.B. bei ACC_EXIT)
	id : die nicht mehr gÅltige ap_id */
	for ( i = 0; i < MAX_XACC; i++ ) {	/* XACC-Liste abklappern */
		if ( xaccs[i].id == id ) {			/* Id gefunden ! */
			xaccs[i].id = NIL;				/* Eintrag in der Liste freigeben */
/* Wert eines Cookies holen, zurÅckgegeben wird TRUE bei Erfolg */
	_p_cookies = *(void **)0x5A0;		/* Zeiger auf Cookiejar holen */
	if ( _p_cookies != NULL ) {		/* wenn Cookiejar installiert ... */
												/* ... dann Cookies abklappern ... */
												/* ... bis der gewÅnschte Eintrag ist */
